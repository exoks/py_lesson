#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£¶‚£¥‚£∂‚£æ‚£ø‚£∂‚£∂‚£∂‚£∂‚£¶‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∂‚†ª‚†õ‚†ü‚†ã‚†â‚†Ä‚†à‚†§‚†¥‚†∂‚†∂‚¢æ‚£ø‚£ø‚£ø‚£∑‚£¶‚†Ñ‚†Ä‚†Ä‚†Ä                   ìêì  numpy ìêî           
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†ã‚†Ä‚†Ä‚†§‚†í‚†í‚¢≤‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£§‚£¨‚£Ω‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚£Ä‚£é‚¢§‚£∂‚£æ‚†Ö‚†Ä‚†Ä‚¢Ä‚°§‚†è‚†Ä‚†Ä‚†Ä‚††‚£Ñ‚£à‚°ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†Ä       Dev: oezzaou </var/spool/mail/oezzaou> 
#  ‚¢Ä‚†î‚†â‚†Ä‚†ä‚†ø‚†ø‚£ø‚†Ç‚††‚†¢‚£§‚†§‚£§‚£º‚£ø‚£∂‚£∂‚£§‚£ù‚£ª‚£∑‚£¶‚£ç‚°ª‚£ø‚£ø‚£ø‚£ø‚°Ä                                              
#  ‚¢æ‚£æ‚£Ü‚£§‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á                                              
#  ‚†Ä‚†à‚¢ã‚¢π‚†ã‚†â‚†ô‚¢¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á       Created: 2025/06/18 09:48:50 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†ë‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á       Updated: 2025/06/18 23:31:51 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚†ø‚†ü‚†õ‚†ã‚†õ‚¢ø‚£ø‚£ø‚†ª‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†á‚†Ä‚¢†‚£ø‚£ü‚£≠‚£§‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚†ò‚£ø‚£ø‚£ø‚†á‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†±‚†§‚†ä‚†Ä‚¢Ä‚£ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä                             ìÜ©‚ôïìÜ™      
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚°Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†ã‚†Ä‚†Ä‚†Ä                     ìÑÇ oussama ezzaouìÜÉ  
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†Ñ‚£Ä‚°Ä‚†∏‚†ì‚†Ä‚†Ä‚†Ä‚††‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              

===[ NumPy: ]===================================================================
* NumPy (short for 'Numerical Python') is a powerfull open-source library in
  python used for 'numerical computing', It provides support for large multi
  dimensional arryas and matrices, along with a wide collection of mathematical
  functions to operate on them efficiently.


# INFO:[ Python Lists VS NumPy Arrays ]==========================================
# - Lists are implemented using 'dynamic arrays' in C via the CPython
#   interpreter.
#   . Each list element is a 'pointer' to a python object 
# -> This means lists are: 
#   . Heterogeneous: can store anything (int, str, object)
#     (polymorphism + single root object model) 
#   . Flexible but slower: every access requires pointer
#     dereferencing + type checking. 
# - NumPy Arrays (ndarray) are implemented in c and behave like 'contigous'
#   'memory blocks' storing raw data (not pointers)
#   . It does not use object to represent a raw data, it does use primitive
#     data type (bi bassata homa l arrays dyal c)
#   . All elements are of the 'same fixed data type' (float64, int32)
#   ______________________________________________________________________
#   | Feature         | Python List         | NumPy Array                |
#   |-----------------|---------------------|----------------------------|
#   | Element storage | Pointers to objects | Raw bytes (fixed-size)     |
#   | Homogeneity     | Can mix types       | Fixed dtype                |
#   | Memory locality | Poor                | Excellent (cache-friendly) |
#   | Vectorization   | Manual loops        | Native (SIMD, BLAS)        |
#   | Type checking   | Dynamic (slow)      | Static (fast)              |
#   |_________________|_____________________|____________________________|


> [ NumPy Array Object attributes: ]
  ____________________________________________________________________
  | Component | Description                                          |
  |-----------|------------------------------------------------------|
  | data      | Pointer to the memory block (raw C array)            |
  | dtype     | Data type of each element (`float32`, `int64`, etc.) |
  | shape     | Dimensions of the array (e.g., (3, 4))               |
  | strides   | Number of bytes to step in each dimension            |
  | ndim      | Number of dimensions (1, 2, 3, ...)                  |
  | flags     | Memory layout flags (C-contiguous, etc.)             |

===[ Array Creation: ]===
* There are two main methods to create 'ndarray' 

   |-----------------------[ Array Creation Methods ]----------------------|
   |                                    |                                  |
[ ndarray class consturctor ]           |          [ built-in Function Factory ]
> np.ndarray(shape=(3, 2),              | > Use built-in functions:            
          dtype=np.int32, buffer=data)  |   . np.array()  . np.eye()
. 'shape': is tuple                     |   . np.zeros()  . np.diago() 
. 'dtype': is the data type, (int32,    |   . np.onces()  . np. 
  int64, float32, float64, etc)         |   . np.full()   . np. 
. 'buffer': data                        |   . np.empty()  . np. 
# NOTE:=================================|=======================================
# THIS IS NOT COMMONLY USED, it is      | This is the most commonly used method
# low-level and mainly for advanced     | to create arrays.
# memory control.                       |

> [ built-in Factory Functions: ]
  1|. 'np.array()', it does accept python list.
      [ my_array = np.array([elem1, elem2, elem3, ...]) ] 

    - You can Use the same idea in case of multidimential array 
      [ my_array = np.array([ [...],
                              [...],
                               ...   ])]

    |> Full Prototype Function: 
        numpy.array(
            object,
            dtype=None,
            *,
            copy=True,
            order='K',
            subok=False,
            ndmin=0,
            like=None
        )
        _______________________________________________________________________
        | Parameter | Type       | Description                                |
        |-----------|------------|--------------------------------------------|
        | object    | array.like | Input data (list, tuple, ndarray, etc.) to | 
        |           |            | be converted into an array                 |
        |-----------|------------|--------------------------------------------|
        | dtype     | data-type, | Desired data type of the array (e.g.,      |
        |           | (optional) | `np.int32`, `np.float64`).                 |
        |-----------|------------|--------------------------------------------|
        | copy      | bool,      | If `True`, a copy of the data is made. if  |
        |           | (optional) | `False`, a copy is only made if necessary  |
        |           |            | Default is `True`                          |
        |-----------|------------|--------------------------------------------|
        | order     | {'K', 'A', | Memory layout of the array:                |
        |           |  'C', 'F'} | `'C'`: C-style (row-major)                 |
        |           | (optional) | `'F'`: Fortran-style (column-major)        |
        |           |            | `'A'`: Any                                 |
        |           |            | `'K'`: Match input as closely as possible  |
        |-----------|------------|--------------------------------------------|
        | subok     | bool,      | If `True`, subclasses are passed through;  |
        |           | (optional) | otherwise, a base-class array is returned  |
        |-----------|------------|--------------------------------------------|
        | ndmin     | int,       | Specifies the minimum number of dimensions |
        |           | (optional) | that the resulting array should have.      |
        |-----------|------------|--------------------------------------------|
        | like      | array.like,| Reference object to allow the creation of  | 
        |           | (optional) | that are not NumPy arrays. Used for array  |
        |           |            | creation dispatching                       |
        |-----------|------------|-(introduced in NumPy 1.20)-----------------|

  2|. 'np.zeros()' creates a new array 'filled with zeros', it commonly used for
      initializing arrays or tensors before performing computations.
      > [ Syntax: ] 
        numpy.zeros(shape, dtype=float, order='C')

  3|. 'np.onces()' creates a new array 'filled with ones' 
      > [ Syntax: ]
        numpy.ones(shape, dtype=None, order='C')

  4|. 'np.full()' creates an array filled with a specified value 
      > [ Syntax: ]
        numpy.full(shape, fill_value, dtype=None, order='C')

  5|. 'np.empty()' creates an uninitialized array
      > [ Syntax: ]
        numpy.empty(shape, dtype=float, order='C')

> [ Identity Matrix: ]

  > [ Syntax: ]
      >>[   np.eye(shape, dtype=float)    ]<<

    # NOTE:===========================================================
    # - The identity Matrix is very important Matrix in linear algebra  
    # - The identiy Matrix always squared => that is way it takes only
    #   one dimention in 'shape'. 
    
    . 'shape': is tupple that defines the dimentions of the tensor (m, n) 
    . 'dtype': (optional) defines the data type of the data stored in the tensor
               (default float)
    . 'order': (Optional) whethere to sore the multi-dimensional data in 
               row-major ('C') or column-major ('F') order, (Default 'C').
 
> [ Saving Array: ]
  * 'np.save()' is used to 'save NumPy array to a binary file' in '.npy' format
    this is 'fast, compact' and 'preserves' all array information such as:
    - Shape
    - Data Type
    - Endianness
    - For structured arrays: field names and metadata
  
  > [ Syntax: ]
    # data will be saved in binary file called my_array.npy
    np.save('my_array', ndarray) 
    # data will be loaded from my_array.npy file and return ndarray object 
    np.lod('my_array.npy')

> [ Tensors: ]
  - Tensor comes from the latin word 'tendere' meanint 'to stretch'
  - Scalar: is a single number that describe magnitude and direction. That is 
            way the 1D array still make sense, same rules still applied 
            (vector describe, 'direction and magnitude')
            |=> Vector of length 1 or matrix (1x1)
  - vector: Is an object mathematical quentity that describes magnitude
            and direction (sum of scalars) (Row vector or Column Vector)
  - matrices: sum of vectors => (system equation or transformation) 
  - Tensor: is a 'mathematical object' that 'generalizes', 'Scalars', 'vectors'
    , and 'matrices' to 'higher dimensions'. 
      . A 'saclar' is a '0th-order' tensor (just a number)=> rank0 |1x1  
      . A 'vector' is '1st-order tensor' (a list of numbers)=> rank1 |1xm or mx1 
      . A 'matrix' is '2nd-order tensor' (a grid or table of numbers) rank2|mxn 
    * 'Tensors' can go beyond this: => rank3 | (m x n x k)
      . A '3rd-order' tensor might be a cube of numbers (for 'RGB' image data)
      . 'Higher-order' tensors extend this idea to more dimenstions

# INFO:=========================================================================
# - Tensors represent 'multilinear relationships' between sets of vectors and
#   are used to encode data with multiple indices or directions.
# > [ Use Cases: ]
#   * Physics: Tensors describe physical quantities like stress, strain
#   * Engineering: Used in continuum mechanics
#   * Machine learning: Frameworks like TensorFlow  use tensors to store
#                       and compute multi-dimensional data. 
#   * Computer Vision: Tensor represent images, videos or feature maps
# > [ Summary: ] Tensors are the natural extension of vectors and matrices
#                to represent complex, multi-dimensional data.
