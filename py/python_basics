#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£¶‚£¥‚£∂‚£æ‚£ø‚£∂‚£∂‚£∂‚£∂‚£¶‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∂‚†ª‚†õ‚†ü‚†ã‚†â‚†Ä‚†à‚†§‚†¥‚†∂‚†∂‚¢æ‚£ø‚£ø‚£ø‚£∑‚£¶‚†Ñ‚†Ä‚†Ä‚†Ä                  ìêì  python ìêî           
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†ã‚†Ä‚†Ä‚†§‚†í‚†í‚¢≤‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£§‚£¨‚£Ω‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚£Ä‚£é‚¢§‚£∂‚£æ‚†Ö‚†Ä‚†Ä‚¢Ä‚°§‚†è‚†Ä‚†Ä‚†Ä‚††‚£Ñ‚£à‚°ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†Ä   Student: oezzaou <oezzaou@student.1337.ma> 
#  ‚¢Ä‚†î‚†â‚†Ä‚†ä‚†ø‚†ø‚£ø‚†Ç‚††‚†¢‚£§‚†§‚£§‚£º‚£ø‚£∂‚£∂‚£§‚£ù‚£ª‚£∑‚£¶‚£ç‚°ª‚£ø‚£ø‚£ø‚£ø‚°Ä                                              
#  ‚¢æ‚£æ‚£Ü‚£§‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á                                              
#  ‚†Ä‚†à‚¢ã‚¢π‚†ã‚†â‚†ô‚¢¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á       Created: 2024/10/16 11:15:25 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†ë‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á       Updated: 2024/10/17 14:11:10 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚†ø‚†ü‚†õ‚†ã‚†õ‚¢ø‚£ø‚£ø‚†ª‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†á‚†Ä‚¢†‚£ø‚£ü‚£≠‚£§‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚†ò‚£ø‚£ø‚£ø‚†á‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†±‚†§‚†ä‚†Ä‚¢Ä‚£ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä                             ìÜ©‚ôïìÜ™      
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚°Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†ã‚†Ä‚†Ä‚†Ä                     ìÑÇ oussama ezzaouìÜÉ  
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†Ñ‚£Ä‚°Ä‚†∏‚†ì‚†Ä‚†Ä‚†Ä‚††‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              

					> [ Python ] <

- When we type a python code what is the steps that pass throws to get executed:

	source_code.py => python interpreter (Compiler -> source_code.pyc -> virtual machine) => exected

- python has A CLI interface like bash that's explain why we call it as python script

 * Interpreted VS Compiled Languages
	+ Compiled Language:
	- Compiled languages are converted entirely into machine code (binary instruction) by a compiler before the program is run
	- It creates an executable file that can be directly executed by OS
	- Once Compiled does not need the source code or compiler anymore to run.
	+ Interpreted Language:
	- executed line-by-line or statement-by-statement by interpreter
	- the interpreter reads to source code, converts it to an intermediate form (byte code .pyc), and then exec directly

> [ Variables: ]
	function type() will gives you the data type of the variables

	- numbers: int complex float ...
	- String
	- Booleans: true, false
	- lists: dynamic array (like linked-list)
	- Tuples: Arrays
	- Sets: set different data types (1, 'Hello', 2, 'World', 3.2)
	- Dictionarys: key, value (like: map in c++)

	Note: everything in python is an object

Arithmetic Operators:
	- Rest is the same as C/C++ JAVA
	- a ** b = Exponent
	- a // b =  Floor divide

Comparison Operators:
	- Is the same as C/C++ JAVA

Logical operator:
	- && : and
	- || : or
	- !  : not

Bitwise Operators:
	- Bitwise XOR: ^		
	- Bitwise Compliment Or: ~

Assignment Operators:
	- a **= b
	- a //= b
	- Rest is the same as C/C++ JAVA

Membership Operators:
	- in: a in arr : is a a member in arr => true/false
	- not in: a not in arr : is a not a member in arr => true/false

Identity Operators:
	- is : a is b
								> are the same object in memory or not
	- is not : a is not b

> [ Conditions: ]
	if statemnt syntx:
		if condition:
			# part of code
		elif condition:
			# part of code
		else:
			# part of code
> [ Loops: ]

instead of using comparision operators to define the range, python provides a range function:
	syntax: range(start, end, increment)

	for loop syntax:
		for element in sequence:
			statements

	ex:
		for index in range(1, 5, 1):
			# something

	while loop syntax:
		while condtion:
			# something
		else: it can be done with while

!!!: python use grabage collector mechanism to clear the unused variables

- Varibales are objects stored in memory's heap, but the reference (pointers) to this object are stored in stack, this topic explains
exactly why python use garbage collector mechanism to free resources that has been reserved.

But in hight level of abstruction python abstract the pointers and objects in reference X, instead of working directly with pointers 
python allow to use in simple way, as a varibales where you don't even know where stored or how memory managment it works.

* reference in c++: refers to alias assigned to varibale in run time (&var: does not have a space in memory like pointers).
* reference in python: refers to the process of high-level of abstraction.

python types:
+ Immutable types: (int, float, str, tuple) leads to create a new memory allocation in heap (new object).
+ mutable types: (list, dictionary, set) changing a values modifies the existing object in the heap

!!!: An existing library: is caled MODULE in python 

what is intresting about python that support negative index: using negative index means reverse the order

ex:
-1: is the index of the last element
-2: is the index of the element before the last

> [ Variables in details: ]
	+++ > List
	advs:
		- It can store different data types, means that use the principale of polymorphism to achive that.
		- valx E [mutuable, immutable]
	syntax:
		> listName = [val1, val2, ..., valN]
		> listName = [defautlValue] * N, N: number of elemnts in the list

del : will delete the element from the list.

	syntax:
		del list[index]				: deleting one element
		del list[index0: indexN]	: deleting a range of elemnts
		del list					: deleting the entire list

[X: Y] : it will give a range from x -----> y
ex: print([x: y]), print from index x ----> y
> operators used with list
	+: to add list to another 
		list3 = list1 + list2: list 3 will have the elements of list1 & list2
	*: used before 
		list = [defautlValue] * N, N E [1, infinity]
	in: to search in element in list or in for loop
		x in list ==> (true/false)
	
Function of class List:
	- append(obj): add new element to list
	- insert(index, obj) add the element in the specific index
	- pop(index): remove the element at index
	- clear(): remove all elements
	- copy(): return a copy from that object
	- count(obj): return the number of elements with the same value
	- remove(obj): remove the first element found
	- sort(reverse=False): sort the list
	- reverse(): reverse the list

	> existing function to use:
		+ len(list) : return len
		+ min(list) : return min
		+ max(list) : return max
		+ list(sequence) : return copy from sequence object

!!!: list is dynamic array it gets realocated each time according to shefting values (over-allocation).
since all objects in python extands from the base class object, polymorphism is here that explain why we could store
different object in the list, using polymorphism
+ this is a away of using polymorphism in high-level way or abstraction.
+ python is dynamic typing & late binding: means the type is checked only when it is used
+ in low-level the list is nothing but a dynamic array that stores pointers to objects in stack but the object are stored in heap

	+++ > Tuple (topule)
	def: is a fixed-size array of pointers (pholymorphism always there), can't be modified (no appending, inserting, or deleting)
	stored in read-only memory areas, immutable (adjv: not changing or unable to be changed)
	syntax:
			tuple = (val1, val2, ..., valN);
	tuple are used a lists but it can't be modifed like lists,
	why tuples ?
	+ tuples are faster to reach the element than lists since are read-only 
	+ more secure read-only values

	+++ > Set
		sets are implemented using a hash table (know as hash sets) data structure.
	each element added to the set is passed through a hsh function, which produces a fixed-size integer hash value, 
	this hash table is used to determine where the element will be placed in the hash table.
	+ Sets does not gurantee the order of element.
	+ Sets store only collection of unique elements.
	+ Sets is dynamic-resizing
	+ hash tables are splited to buckets each backet stores and element
	syntax:
		set = {val1, val2, ..., valN}

	!!!: del is used to delete the whole set not the element.
		index can't be used to search for an element (instead use in operator)

	+ position of the values depends on the hash generated to element.

!!!!!!!!!: i don't know how to use hash tables in C or how it works, do not forget to read about hash tables and how it works?

	Set class in python:
		+ add(element): to add an element
		+ discrad(element): delete a specific element from the set
		+ remove(element): delete But it throw and exception if there is another element with the same value
		+ clear(): remove all elements of the set
		+ pop(): remove a random element and return its value
		+ copy(): return a copy from the set
		+ difference(set_instance): return diff between sets
		+ union(set_instance): returns a new set with the value of setObject and set passed as parametere
		+ all the other function are just operations between sets
	Existing function:
		+ the same as lists 

	+++ > Dict (Dictionary)
		_ dict are implemented as hash tables.	
		syntax:
			dict = {
				key1: value1
				key1: value2
				key1: value3
			}
		- access elements: using [key] subscrip operators or get(key) function for for loop (key in dict)
		- adding element: dict[key] = value
		- del to remove any element or dictionary itself

		+ Function of the class:
			+ clear()
			+ copy()
			+ popitem() : return the last one added after removing it
			+ pop(key[, default]): remove the element with this key
			+ get(key[, default]): return the value of that key
			+ keys(): return an array of keys
			+ values(): return an array of values
			+ items(); return elements stored in the array
			+ fromkeys(sq[, values]): 
			+ setdefault(key, [, default]):
			+ update([other]):

> [ Functions : ]
	+ Functions that exist in python are called build-in functions
	+ Functions created by user is called user-defined functions
	syntax:
		def function_name(args=defautl_value):
			# function body
		return [experssion]
		
	call: function_name()
	+ python gives the ability to add default values to parameters if not provided exactly as template in C++.
	+ The args's order is not important, we can pass args the order that we want.
		syntax: fun(ars2=val2, arg1=val1)
	+ python also has functions similar to variadic functions in c (when we could provide as much as we want from vars)
		syntax: fun(*args):
		- arguments are grouped in tuple which makes it easy and fast to access.
	+ Lambda function: is used to define a function without name (anonymous function)
		- lambda [arg1, [arg2, ..., argN]: expression
		ex: x = lambda 1, 2: 1 - 2, assigning x to anonymous function.
		use: x(3, 4)

> [ Modules: ]
	+ The most simpliest thing in the word, instead of creating header files or .hpp and .cpp files in c++ for example
	all you have to do is create a python script file and then use import [file_name] to import this file
	+ the concept of forward declaration to not include all the files, it is the same concept in python, where you have to
	use this syntax: to achieve something close to forward declaration

		+ based syntax: from [file_name] as [alias]
			- how to use it ?
			* syntax: [module_name/alias].[content]

		+ syntax: from [file_name] import [class], [function] / *: i you want to import everything in module
			- how to use it ?
			* syntax: [content]

	Note: forward declaration inform the compiler about the function, and this feature can be used to include a specific
	function instead of including the whole header file for example.
	+  The main role of forward declaration in C/C++ is to inform the compiler about the existence of a function, class,
	or variable before it is fully defined.
	+ using dir(module) function will display all module content.
