#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£¶‚£¥‚£∂‚£æ‚£ø‚£∂‚£∂‚£∂‚£∂‚£¶‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∂‚†ª‚†õ‚†ü‚†ã‚†â‚†Ä‚†à‚†§‚†¥‚†∂‚†∂‚¢æ‚£ø‚£ø‚£ø‚£∑‚£¶‚†Ñ‚†Ä‚†Ä‚†Ä           ìêì  python_basics ìêî           
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†ã‚†Ä‚†Ä‚†§‚†í‚†í‚¢≤‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£§‚£¨‚£Ω‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚£Ä‚£é‚¢§‚£∂‚£æ‚†Ö‚†Ä‚†Ä‚¢Ä‚°§‚†è‚†Ä‚†Ä‚†Ä‚††‚£Ñ‚£à‚°ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†Ä   Student: oezzaou <oezzaou@student.1337.ma> 
#  ‚¢Ä‚†î‚†â‚†Ä‚†ä‚†ø‚†ø‚£ø‚†Ç‚††‚†¢‚£§‚†§‚£§‚£º‚£ø‚£∂‚£∂‚£§‚£ù‚£ª‚£∑‚£¶‚£ç‚°ª‚£ø‚£ø‚£ø‚£ø‚°Ä                                              
#  ‚¢æ‚£æ‚£Ü‚£§‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á                                              
#  ‚†Ä‚†à‚¢ã‚¢π‚†ã‚†â‚†ô‚¢¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á       Created: 2024/10/16 11:15:25 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†ë‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á       Updated: 2025/05/30 16:15:27 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚†ø‚†ü‚†õ‚†ã‚†õ‚¢ø‚£ø‚£ø‚†ª‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†á‚†Ä‚¢†‚£ø‚£ü‚£≠‚£§‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚†ò‚£ø‚£ø‚£ø‚†á‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†±‚†§‚†ä‚†Ä‚¢Ä‚£ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä                             ìÜ©‚ôïìÜ™      
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚°Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†ã‚†Ä‚†Ä‚†Ä                     ìÑÇ oussama ezzaouìÜÉ  
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†Ñ‚£Ä‚°Ä‚†∏‚†ì‚†Ä‚†Ä‚†Ä‚††‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              

===============================>> [ Python ] <<=================================
- When we type a python code what is the steps that pass throws to get executed:

source_code.py
=> python interpreter (Compiler -> source_code.pyc -> virtual machine)
=> exected

- python has A CLI interface like bash that's explain why we call it as python
  script

 * Interpreted VS Compiled Languages
	+ Compiled Language:
	- Compiled languages are converted entirely into machine code
    (binary instruction) by a compiler before the program is run
	- It creates an executable file that can be directly executed by OS
	- Once Compiled does not need the source code or compiler anymore to run.
	+ Interpreted Language:
	- executed line-by-line or statement-by-statement by interpreter
	- the interpreter reads to source code, converts it to an intermediate form
    (byte code .pyc), and then exec directly

===[ Variables: ]===============================================================
	function type() will gives you the data type of the variables

	- numbers: int complex float ...
	- String
	- Booleans: true, false
	- lists: dynamic array (like linked-list)
	- Tuples: Arrays (readonly)
	- Sets: set different data types (1, 'Hello', 2, 'World', 3.2)
	- Dictionarys: key, value (like: map in c++)

	Note: everything in python is an object

Arithmetic Operators:
	- Rest is the same as C/C++ JAVA
	- a ** b = Exponent
	- a // b =  Floor divide

Comparison Operators:
	- Is the same as C/C++ JAVA

Logical operator:
	- && : and
	- || : or
	- !  : not

Bitwise Operators:
	- Bitwise XOR: ^		
	- Bitwise Compliment Or: ~

Assignment Operators:
	- a **= b
	- a //= b
	- Rest is the same as C/C++ JAVA

Membership Operators:
	- in: a in arr : is a a member in arr => true/false
	- not in: a not in arr : is a not a member in arr => true/false

Identity Operators:
	- is : a is b
								> are the same object in memory or not
	- is not : a is not b

===[ Conditions: ]==============================================================
	if statemnt syntx:
		if condition:
			# part of code
		elif condition:
			# part of code
		else:
			# part of code

===[ Loops: ]===================================================================

- instead of using comparision operators to define the range, python provides a
  range function:
	
  syntax: range(start, end, increment)

	for loop syntax:
		for element in sequence:
			statements

	ex:
		for index in range(1, 5, 1):
			# something

	while loop syntax:
		while condtion:
			# something
		else: it can be done with while

# ERROR: python use grabage collector mechanism to clear the unused variables

- Varibales are objects stored in memory's heap, but the reference (pointers)
  to this object are stored in stack, this topic explains
# INFO:=========================================================================
# This is exactly why python use garbage collector mechanism to free resources |
# that has been reserved form the kernel.                                      |
# ==============================================================================

- But in hight level of abstruction python abstract the pointers and objects in
  reference X, instead of working directly with pointers.
- python allow to use in simple way, as a varibales where you don't even know
  where stored or how memory managment it works.

* reference in c++: refers to alias assigned to varibale in run time 
  (&var: does not have a space in memory like pointers).
* reference in python: refers to the process of high-level of abstraction.

===Python Types: ===
+ Immutable types [ Fixed Size]: (numbers[int, float], str, tuple) leads to
  create a new memory allocation in heap (new object).
+ Mutable types: (list, dictionary, set) changing a values modifies the
  existing object in the heap

# INFO: An existing library: is caled MODULE in python 
- What is intresting about python that it support negative index:
  using negative index means reverse the order
ex:
  => -1: is the index of the last element
  => -2: is the index of the element before the last

===[ Variables in details: ]====================================================
>> [ List: ]
	advs:
		- It can store different data types, means that use the principale of
      polymorphism to acheive that.
		- valx E [mutuable, immutable]

	syntax:
		> listName = [val1, val2, ..., valN]
		> listName = [defautlValue] * N, N: number of elements in the list

del : will delete the element from the list.

	syntax:
		del list[index]				: deleting one element
		del list[index0: indexN]	: deleting a range of elemnts
		del list					: deleting the entire list

[X: Y] : it will give a range from x -----> y
ex: print([x: y]), print from index x ----> y

> operators used with list
	+: to add list to another 
		list3 = list1 + list2: list 3 will have the elements of list1 & list2
	*: used before 
		list = [defautlValue] * N, N E [1, infinity]
	in: to search in element in list or in for loop
		x in list ==> (true/false)
	
Function of class List:
	- append(obj): add new element to list
	- insert(index, obj) add the element in the specific index
	- pop(index): remove the element at index
	- clear(): remove all elements
	- copy(): return a copy from that object
	- count(obj): return the number of elements with the same value
	- remove(obj): remove the first element found
	- sort(reverse=False): sort the list
	- reverse(): reverse the list

	> existing function to use:
		+ len(list) : return len
		+ min(list) : return min
		+ max(list) : return max
		+ list(sequence) : return copy from sequence object

# NOTE:=========================================================================
# - list is dynamic array it gets realocated each time according to shefting   |
#   values (over-allocation).                                                  |
# - since all objects in python extands from the base class object, polymorph  |
# is here to explain why we could store different object in the list.          |
#   + This is a method of using polymorphism in high-level way or abstraction. |
#   + Python is dynamic typing & late binding: means the type is checked only  |
#     when it is used.                                                         |
#   + in low-level the list is nothing but a dynamic array that stores pointers|
#     to objects in stack but the object are stored in heap.                   |
# ==============================================================================

 >> [ Tuple (topule): ]
	> def:  is a fixed-size array of pointers (pholymorphism always there),
        can't be modified (no appending, inserting, or deleting) stored in
        read-only memory areas, immutable (adjv: unable to be changed)

	> syntax:
			tuple = (val1, val2, ..., valN);
	- Tuple are used a lists but it can't be modifed like lists,
	> Why tuples ?
	+ Tuples are faster to reach the element than lists since are read-only 
	+ More secure read-only values.

>> [ Set: ]
	> def: sets are implemented using a hash table (know as hash sets) data
    structure, each element added to the set is passed through a hash function,
    which produces a fixed-size integer hash value, This hash table is used to
    determine where the element will be placed in the hash table.
	+ Sets does not gurantee the order of element.
	+ Sets store only collection of unique elements.
	+ Sets is dynamic-resizing
	+ hash tables are splited to buckets each backet stores and element

	> syntax:
		set = {val1, val2, ..., valN}

# WARNING:======================================================================
# - del is used to delete the whole set not the element.                       |
# - index can't be used to search for an element (instead use in operator)     |
# - position of the values depends on the hash generated to element.           |
# ==============================================================================

!!!!!!!!!: i don't know how to use hash tables in C or how it works, do not
  forget to read about hash tables and how it works?

	Set class in python:
		+ add(element): to add an element
		+ discrad(element): delete a specific element from the set
		+ remove(element): delete But it throw and exception if there is another
      element with the same value
		+ clear(): remove all elements of the set
		+ pop(): remove a random element and return its value
		+ copy(): return a copy from the set
		+ difference(set_instance): return diff between sets
		+ union(set_instance): returns a new set with the value of setObject and
      set passed as parametere
		+ all the other function are just operations between sets
	Existing function:
		+ the same as lists 

>> [ Dict (Dictionary): ]
		- dict are implemented as hash tables.	
		> syntax:
			dict = {
				key1: value1
				key1: value2
				key1: value3
			}
		- access elements: using [key] subscrip operators or get(key) function
      for for loop (key in dict)
		- adding element: dict[key] = value
		- del to remove any element or dictionary itself

		+ Function of the class:
			+ clear()
			+ copy()
			+ popitem() : return the last one added after removing it
			+ pop(key[, default]): remove the element with this key
			+ get(key[, default]): return the value of that key
			+ keys(): return an array of keys
			+ values(): return an array of values
			+ items(); return elements stored in the array
			+ fromkeys(sq[, values]): 
			+ setdefault(key, [, default]):
			+ update([other]):

===[ Functions : ]==============================================================
	+ Functions that exist in python are called build-in functions
	+ Functions created by user is called user-defined functions
	> syntax:
		def function_name(args=defautl_value):
			# function body
		return [experssion]
		
	call: function_name()
	+ Python gives the ability to add default values to parameters if not provided
    exactly as template in C++.
	+ The args's order is not important, we can pass args the order that we want.
		syntax: fun(ars2=val2, arg1=val1)
	+ Python also has functions similar to variadic functions in c 
    (when we could provide as much as we want from vars)
		syntax: fun(*args):
		- arguments are grouped in tuple which makes it easy and fast to access.
	+ Lambda function: is used to define a function without name
    (anonymous function)
		- lambda [arg1, [arg2, ..., argN]: expression
		ex: x = lambda 1, 2: 1 - 2, assigning x to anonymous function.
		use: x(3, 4)

===[ Modules: ]=================================================================
+ The most simpliest thing in the word, instead of creating header files or .hpp
  and .cpp files in c++ for example all you have to do is create a python script
  file and then use import [file_name] to import this file.
+ the concept of forward declaration to not include all the files, it is the
  same concept in python, where you have to use this syntax: to achieve something
  close to forward declaration : 

		+ based syntax: from [file_name] as [alias]
			- how to use it ?
			* syntax: [module_name/alias].[content]

		+ syntax: from [file_name] import [class], [function] / *: Import everything 
			- how to use it ?
			* syntax: [content]

# NOTE:=========================================================================
# forward declaration inform the compiler about the function, and this feature |
# can be used to include a specific function instead of including the whole    |
# header file for example.                                                     |
# + The main role of forward declaration in C/C++ is to inform the compiler    |
#   about the existance of a function, class, or variable before it is fully   |
#   defined.                                                                   |
# + using dir(module) function will display all module content.                |
# ==============================================================================

===[ Date & Time: ]============================================================
- Python contains more than module to deal with work and time.
  * datetime 
  * calendar

>> [ datetime: ]===
  - Classes
    * date: functions to deal with 'date'
    * time: functions to deal with 'time' 
    * datetime: functions to deal with 'date & time'
    * timedelta: functions to deal with diff between time 
    * timezone: functions to deal with diff between date according to zone
    ex:
      - datetime.datetime.now() => return date in form [yy-mm-dd hh-mm-ss] 

  - Constructor
    class datetime.datetime(year, month, day, hour=0, minute=0, second=0,
    microsecond=0, tzinfo=None, *, fold=0)

  - Change Date Format: strftime()
    strftime('')
    - '%a': display the day in form of 'Mon', 'thu', ...
    - '%A': display the full day name 'Monday'. 
    - '%w': display day of the week in form of number sun: 0, mon: 1, ... 
    - '%d': display day of the month in form of number 01 -> 31

    - '%b': display the month in the form of 'Dec' 
    - '%B': display the month in the form of 'Decomber'
    - '%m': display the number of the month according to the year 

    - '%y': display the year in form of '18'
    - '%Y': display the full form of the year '2018'

    - '%H': display hour in form of '24' 00 -> 23 
    - '%I': display hour in form of '12' 00 -> 12
    - '%p': to show 'AM' or 'PM'
    - '%M': number of munites
    - '%S': number of seconds
    - '%f': show microsecond instead of seconds 

    - '%j': day number according to the year 001 => 366 
    - '%U': week number according to the year 00 => 53: first day is sunday
    - '%W': week number according to the year 00 => 53: first day is monday 
    - '%c': show time & date in form of 'Mon Dec 3 18:52:05 2020'
    - '%x': show date in form of '16/02/2024'
    - '%X': show time in the form of '18:52:05' 

>> [ calendar: ]===

===[ Format Specification Mini-Language ]=======================================
- In python there is a form similar to the one in C or c++ in printf function
  |C/C++ | [flags][width][.precision][conversion]%

  f-strings / str.format() 
  |Python| f{var:[flags][width][.precision][type]}
    - Flags: alignment, sign, padding, comma separators | ':', ',' adds commas 
    - Width: min nbrs of chars to display | '10' 
    - .precision: .2f -> 2 dicimal places 
    - Type: conversions (f, d, s, x ...) 
      - Types:
      'd': int dicimal
      'b': binary format {10:b} => 1010
      'o': octral format
      'x': hex format, lowercase
      'X': hex format, upper case
      'n': as as 'd' but usese localseprator => 1000 | 1,000
      'e': expononential notaion, lowercase
      'E': exponential notaion, uppercase
      'f': fixed point notation 
      'F': fixed point notation, uppercase
      'g': general format, uses fixed or exponential, whichever is shorter
      'G': same thing, in uppercase
      '%': multiplies by 100 + %

===[ String Literal Prefixes: ]=================================================
- f"": formatted string literal (f-string): varibale insertion 
- r"": row-string literl: treats '\' as literal character, no escape sequences
- b"": byte string literal: represent a byte object
- u"": Unicode String Literal
- fr"" or rf"": f-string & r-string

===[ main function: ]===========================================================
- main() is used to improve 'code organization and readability'
- It allows the script to be 'imported as a module' without executing the main 
  logic automaticaly.
- It follows the 'best practices' used in many other programming languages
  (C/C++, Java)

  > Syntax: 
    if __name__ == "__main__":
      main()

    # INFO:=====================================================================
    # - This statement ensures that the script runs 'only when executed        |
    #   directly', no when imported as a module.                               | 
    # ==========================================================================

  - When you run the script directly:
      bashcmd: python script.py
    * The __name__ variable is set to "__main__", so "main()" executes.

  - When you import the script in another python file:
      bashcmd: import script #script.py
    * the '__name__' i set to "script", so "main()" does not run.

# INFO:=========================================================================
# 1| The __name__ varibale in python is a special built-in variable that helps |
#     determine a script is being 'run directly' or imported as a module       |
#   - Every python script has a build-in variable called '__name__'            |
#   - When script is 'run directly', '__name__' is set to "__main__"           | 
#   - When a script is 'imported as a module', '__name__' is set to the module's
# ============================================================================== 

- '__name__' is a safegurad to not run the module it is used as module, in c/c++
  only one entry point is exist, in python there is another story, every file
  can have a main function.

===[ documentation in python: ]=================================================
- The __doc__ attr in python is 'special buil-in attribute' that stores the 
  'docstring' (documentation string) of a module, class function for method.

  bashcmd:
    > Syntax:
      * Module : 
      """ This is a documnation for module"""
      print(__doc__)
      help(__doc__)

      * def fun():
        """ This is a documentation for function"""
      - print(fun.__doc__)
      or
      - help(greet)

      * class Person:
        """ This is a documentation for class"""
      - print(Person.__doc__)
      or
      - help(Person)

# CONCLUSION:===================================================================
# * Why Use __doc__?                                                           |
#   ‚úÖ Improves code readabilit.                                                |
#   ‚úÖ Helps with auto-documentation (e.g., help(), Sphinx)                     |
#   ‚úÖ Best practice in Python for documentatio.                                |
# ==============================================================================

================================================================================
