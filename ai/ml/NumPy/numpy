#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£¶‚£¥‚£∂‚£æ‚£ø‚£∂‚£∂‚£∂‚£∂‚£¶‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∂‚†ª‚†õ‚†ü‚†ã‚†â‚†Ä‚†à‚†§‚†¥‚†∂‚†∂‚¢æ‚£ø‚£ø‚£ø‚£∑‚£¶‚†Ñ‚†Ä‚†Ä‚†Ä                   ìêì  numpy ìêî           
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†ã‚†Ä‚†Ä‚†§‚†í‚†í‚¢≤‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£§‚£¨‚£Ω‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚£Ä‚£é‚¢§‚£∂‚£æ‚†Ö‚†Ä‚†Ä‚¢Ä‚°§‚†è‚†Ä‚†Ä‚†Ä‚††‚£Ñ‚£à‚°ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†Ä       Dev: oezzaou </var/spool/mail/oezzaou> 
#  ‚¢Ä‚†î‚†â‚†Ä‚†ä‚†ø‚†ø‚£ø‚†Ç‚††‚†¢‚£§‚†§‚£§‚£º‚£ø‚£∂‚£∂‚£§‚£ù‚£ª‚£∑‚£¶‚£ç‚°ª‚£ø‚£ø‚£ø‚£ø‚°Ä                                              
#  ‚¢æ‚£æ‚£Ü‚£§‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á                                              
#  ‚†Ä‚†à‚¢ã‚¢π‚†ã‚†â‚†ô‚¢¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á       Created: 2025/06/18 09:48:50 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†ë‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á       Updated: 2025/06/19 18:43:03 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚†ø‚†ü‚†õ‚†ã‚†õ‚¢ø‚£ø‚£ø‚†ª‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†á‚†Ä‚¢†‚£ø‚£ü‚£≠‚£§‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚†ò‚£ø‚£ø‚£ø‚†á‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†±‚†§‚†ä‚†Ä‚¢Ä‚£ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä                             ìÜ©‚ôïìÜ™      
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚°Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†ã‚†Ä‚†Ä‚†Ä                     ìÑÇ oussama ezzaouìÜÉ  
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†Ñ‚£Ä‚°Ä‚†∏‚†ì‚†Ä‚†Ä‚†Ä‚††‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              

===[ NumPy: ]===================================================================
* NumPy (short for 'Numerical Python') is a powerfull open-source library in
  python used for 'numerical computing', It provides support for large multi
  dimensional arryas and matrices, along with a wide collection of mathematical
  functions to operate on them efficiently.


# INFO:[ Python Lists VS NumPy Arrays ]==========================================
# - Lists are implemented using 'dynamic arrays' in C via the CPython
#   interpreter.
#   . Each list element is a 'pointer' to a python object 
# -> This means lists are: 
#   . Heterogeneous: can store anything (int, str, object)
#     (polymorphism + single root object model) 
#   . Flexible but slower: every access requires pointer
#     dereferencing + type checking. 
# - NumPy Arrays (ndarray) are implemented in c and behave like 'contigous'
#   'memory blocks' storing raw data (not pointers)
#   . It does not use object to represent a raw data, it does use primitive
#     data type (bi bassata homa l arrays dyal c)
#   . All elements are of the 'same fixed data type' (float64, int32)
#   ______________________________________________________________________
#   | Feature         | Python List         | NumPy Array                |
#   |-----------------|---------------------|----------------------------|
#   | Element storage | Pointers to objects | Raw bytes (fixed-size)     |
#   | Homogeneity     | Can mix types       | Fixed dtype                |
#   | Memory locality | Poor                | Excellent (cache-friendly) |
#   | Vectorization   | Manual loops        | Native (SIMD, BLAS)        |
#   | Type checking   | Dynamic (slow)      | Static (fast)              |
#   |_________________|_____________________|____________________________|


> [ NumPy Array Object attributes: ]
  ____________________________________________________________________
  | Component | Description                                          |
  |-----------|------------------------------------------------------|
  | data      | Pointer to the memory block (raw C array)            |
  | dtype     | Data type of each element (`float32`, `int64`, etc.) |
  | shape     | Dimensions of the array (e.g., (3, 4))               |
  | strides   | Number of bytes to step in each dimension            |
  | ndim      | Number of dimensions (1, 2, 3, ...)                  |
  | flags     | Memory layout flags (C-contiguous, etc.)             |

===[ Array Creation: ]===
* There are two main methods to create 'ndarray' 

   |-----------------------[ Array Creation Methods ]----------------------|
   |                                    |                                  |
[ ndarray class consturctor ]           |          [ built-in Function Factory ]
> np.ndarray(shape=(3, 2),              | > Use built-in functions:            
          dtype=np.int32, buffer=data)  |   . np.array()  . np.eye()
. 'shape': is tuple                     |   . np.zeros()  . np.diag() 
. 'dtype': is the data type, (int32,    |   . np.onces()  . np.arange()) 
           int64, float32, float64, etc)|   . np.full()   . 
. 'buffer': data                        |   . np.empty()  . 
# NOTE:=================================|=======================================
# THIS IS NOT COMMONLY USED, it is      | This is the most commonly used method
# low-level and mainly for advanced     | to create arrays.
# memory control.                       |

> [ built-in Factory Functions: ]
  1|. 'np.array()', it does accept python list.
      [ my_array = np.array([elem1, elem2, elem3, ...]) ] 

    - You can Use the same idea in case of multidimential array 
      [ my_array = np.array([ [...],
                              [...],
                               ...   ])]

    |> Full Prototype Function: 
        numpy.array(
            object,
            dtype=None,
            *,
            copy=True,
            order='K',
            subok=False,
            ndmin=0,
            like=None
        )
        _______________________________________________________________________
        | Parameter | Type       | Description                                |
        |-----------|------------|--------------------------------------------|
        | object    | array.like | Input data (list, tuple, ndarray, etc.) to | 
        |           |            | be converted into an array                 |
        |-----------|------------|--------------------------------------------|
        | dtype     | data-type, | Desired data type of the array (e.g.,      |
        |           | (optional) | `np.int32`, `np.float64`).                 |
        |-----------|------------|--------------------------------------------|
        | copy      | bool,      | If `True`, a copy of the data is made. if  |
        |           | (optional) | `False`, a copy is only made if necessary  |
        |           |            | Default is `True`                          |
        |-----------|------------|--------------------------------------------|
        | order     | {'K', 'A', | Memory layout of the array:                |
        |           |  'C', 'F'} | `'C'`: C-style (row-major)                 |
        |           | (optional) | `'F'`: Fortran-style (column-major)        |
        |           |            | `'A'`: Any                                 |
        |           |            | `'K'`: Match input as closely as possible  |
        |-----------|------------|--------------------------------------------|
        | subok     | bool,      | If `True`, subclasses are passed through;  |
        |           | (optional) | otherwise, a base-class array is returned  |
        |-----------|------------|--------------------------------------------|
        | ndmin     | int,       | Specifies the minimum number of dimensions |
        |           | (optional) | that the resulting array should have.      |
        |-----------|------------|--------------------------------------------|
        | like      | array.like,| Reference object to allow the creation of  | 
        |           | (optional) | that are not NumPy arrays. Used for array  |
        |           |            | creation dispatching                       |
        |-----------|------------|-(introduced in NumPy 1.20)-----------------|

  2|. 'np.zeros()' creates a new array 'filled with zeros', it commonly used
      for initializing arrays or tensors before performing computations.
      > [ Syntax: ] 
        numpy.zeros(shape, dtype=float, order='C')

  3|. 'np.onces()' creates a new array 'filled with ones' 
      > [ Syntax: ]
        numpy.ones(shape, dtype=None, order='C')

  4|. 'np.full()' creates an array filled with a specified value 
      > [ Syntax: ]
        numpy.full(shape, fill_value, dtype=None, order='C')

  5|. 'np.empty()' creates an uninitialized array
      > [ Syntax: ]
        numpy.empty(shape, dtype=float, order='C')

> [ Identity Matrix: ]

  > [ Syntax: ]
      >>[   np.eye(shape, dtype=float)    ]<<

    # NOTE:===========================================================
    # - The identity Matrix is very important Matrix in linear algebra  
    # - The identiy Matrix always squared => that is way it takes only
    #   one dimention in 'shape'. 
    
    . 'shape': is tupple that defines the dimentions of the tensor (m, n) 
    . 'dtype': (optional) defines the data type of the data stored in the
               tensor (default float).
    . 'order': (Optional) whethere to sore the multi-dimensional data in 
               row-major ('C') or column-major ('F') order, (Default 'C').

> [ Create Array With Random value ]

  1. 'np.diag([el1, el2, el3, ...])': create a 'squared matrix' with diagonal
     data rows (el1, el2, el3, ...)

  2. 'np.arange(start, stop, step)': start -> stop 'Integer numbers', and stop
     is exclusive. 

  3. 'np.linspace(start, stop, arr_length || num=)': start -> stop 'Float Numbers' and 
     stop is 'inclusive' (linspace stands for 'linear space')
     # NOTE:===================================
     # - endpoint=false excludes the stop value 
     # - (start, stop) E Z

  4. 'np.random.rand(rows, cols)': using rand() function from 'random module'
     to generate 'random floats' from a 'uniform distribution' 0|-> 1

  5. 'np.random.uniform(start, stop, size=(rows, cols))' generating
     'random floats' from 'start to stop' from a 'uniform distribution'

  6. 'np.random.random(rows, cols)' generationg random floats from 0|-> 1
     'random distribution'.

  7. 'np.random.randint(start, stop, lenght=, shape=)': generates random
     'integer' numbers from start to end with 'length=number' or
     'shape=(row, col)'
     # NOTE: stop is => exclusive 

  8. 'np.random.normal(mean, standart deviation, shape=(rows, cols))' generates
    'normal distribution'

  9. 'np.random.randn(rows, cols)' generates a 'standard normal distribution'

  # WARNING:====================================================================
  # You need to understand 'Uniform distribution', 'random distribution',
  # 'normal distribution' and 'standard normal distribution' in statistics 

  10. 'np.random.choice(arr, size=)' create another array with 'size=' of
      'random selection' from 'arr' 

  11. 'np.random.permulation(arr)' it create a 'shafled' or 'permulated' array
      from the 'arr' passed as an argument.

> [ Array Manipulation: ]
  1|> 'np.reshape(arr, shape=(rows, cols))' it will reshapes the 'arr' to new
      'shape=' or 'arr.reshape(rows, cols)' 
  # WARNING:> if the new shape does not fit the array, A 'Value error' raise up

  2|> 'x.T', It does 'Transpose' the array, It 'turnes' 'columns to rows' and
      'vice versa'.

  3|> 'np.delete(arr, [index0, index1, ...], axis=0/1)': It does remove the list
      of elements with the [index0, index1, ...] from 'arr'. 
      . axis= 0: represent the row
      . axis= 1: represent the column
      [ numpy.delete(arr, obj, axis=None) ]
      # NOTE:===================================================================
      # - The indexes points on rows/colmns instead of elements, When 'axis' is 
      #   defined.

  4|> 'np.append()': appends 'values' into 'arr' as 'row if axis =0' and as
      'column if axis=1', otherwise add it to the end of list 
      numpy.append(arr, values, axis=None)

  5|> 'np.insert()': insert values at a specific index (of row/colmn if
      axis!=None)
      [ numpy.insert(arr, obj, values, axis=None) ]

  6|> 'np.vstack((y, x))': 'vertical stack', it does stack 'y rows' on the top
      of 'x rows' 
      . (y, x, ...): tupples of tensors 

  7|> 'np.hstack((y, x))': 'horizontal stack', it does stack 'x columns' on the
      'right of x'

  8|> 'np.split(arr, nbr)' > Split into 'nbr' equal parts.

  9|> 'np.isnan(arr)': check if there is a 'not a number value' exist 
      |=> return nan arr: [False, True, Fase, ...]
  
  10|> 'np.isinf(arr)', it checks for '+-infinity' 

  11|> 'np.concatenate((arr1, arr2, ...))', Concatenates arrays into 'one array' 

  12|> 'np.array_equale(arr1, arr2)', it simply compares each element of
       'both arrays' 
       |=> return 'True/False'

  13|> 'np.equal(arr1, arr2)', It does the same as np.array_equal but:
       |=> return array [ True, True, False ] 
       # NOTE: np.not_equale(arr1, arr2) => return array [ False, False, True ]


===[ Saving Array: ]===
  * 'np.save()' is used to 'save NumPy array to a binary file' in '.npy' format
    this is 'fast, compact' and 'preserves' all array information such as:
    - Shape
    - Data Type
    - Endianness
    - For structured arrays: field names and metadata
  
  > [ Syntax: ]
    # data will be saved in binary file called my_array.npy
    np.save('my_array', ndarray) 
    # data will be loaded from my_array.npy file and return ndarray object 
    np.load('my_array.npy')

===[ Tensors: ]===
  - Tensor comes from the latin word 'tendere' meaning 'to stretch'
  - Scalar: is a single number that describe magnitude and direction. That 
            is why the 1D array still make sense, same rules still applied 
            (vector describe, 'direction and magnitude')
            |=> Vector of length 1 or matrix (1x1)
  - vector: Is an object mathematical quentity that describes magnitude
            and direction (sum of scalars) (Row vector or Column Vector)
  - matrices: sum of vectors => (system equation or transformation) 
  - Tensor: is a 'mathematical object' that 'generalizes', 'Scalars', 'vectors'
    , and 'matrices' to 'higher dimensions'. 
      . A 'saclar' is a '0th-order' tensor (just a number)=> rank0 |1x1  
      . A 'vector' is '1st-order tensor' (a list of numbers)=> rank1 |1xm or mx1 
      . A 'matrix' is '2nd-order tensor' (a grid or table of numbers) rank2|mxn 
    * 'Tensors' can go beyond this: => rank3 | (m x n x k)
      . A '3rd-order' tensor might be a cube of numbers (for 'RGB' image data)
      . 'Higher-order' tensors extend this idea to more dimenstions

# INFO:=========================================================================
# - Tensors represent 'multilinear relationships' between sets of vectors and
#   are used to encode data with multiple indices or directions.
# > [ Use Cases: ]
#   * Physics: Tensors describe physical quantities like stress, strain
#   * Engineering: Used in continuum mechanics
#   * Machine learning: Frameworks like TensorFlow  use tensors to store
#                       and compute multi-dimensional data. 
#   * Computer Vision: Tensor represent images, videos or feature maps
# > [ Summary: ] Tensors are the natural extension of vectors and matrices
#                to represent complex, multi-dimensional data.
