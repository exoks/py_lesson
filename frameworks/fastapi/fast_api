#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£¶‚£¥‚£∂‚£æ‚£ø‚£∂‚£∂‚£∂‚£∂‚£¶‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∂‚†ª‚†õ‚†ü‚†ã‚†â‚†Ä‚†à‚†§‚†¥‚†∂‚†∂‚¢æ‚£ø‚£ø‚£ø‚£∑‚£¶‚†Ñ‚†Ä‚†Ä‚†Ä                 ìêì fast_api ìêî           
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†ã‚†Ä‚†Ä‚†§‚†í‚†í‚¢≤‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£§‚£¨‚£Ω‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚£Ä‚£é‚¢§‚£∂‚£æ‚†Ö‚†Ä‚†Ä‚¢Ä‚°§‚†è‚†Ä‚†Ä‚†Ä‚††‚£Ñ‚£à‚°ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†Ä      Eng: oussama <oussama.ezzaou@gmail.com> 
#  ‚¢Ä‚†î‚†â‚†Ä‚†ä‚†ø‚†ø‚£ø‚†Ç‚††‚†¢‚£§‚†§‚£§‚£º‚£ø‚£∂‚£∂‚£§‚£ù‚£ª‚£∑‚£¶‚£ç‚°ª‚£ø‚£ø‚£ø‚£ø‚°Ä                                              
#  ‚¢æ‚£æ‚£Ü‚£§‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á                                              
#  ‚†Ä‚†à‚¢ã‚¢π‚†ã‚†â‚†ô‚¢¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á       Created: 2025/10/27 13:58:23 by oussama
#  ‚†Ä‚†Ä‚†Ä‚†ë‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á       Updated: 2026/01/29 11:09:27 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚†ø‚†ü‚†õ‚†ã‚†õ‚¢ø‚£ø‚£ø‚†ª‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†á‚†Ä‚¢†‚£ø‚£ü‚£≠‚£§‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚†ò‚£ø‚£ø‚£ø‚†á‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†±‚†§‚†ä‚†Ä‚¢Ä‚£ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä                             ìÜ©‚ôïìÜ™      
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚°Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†ã‚†Ä‚†Ä‚†Ä                     ìÑÇ oussama ezzaouìÜÉ  
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†Ñ‚£Ä‚°Ä‚†∏‚†ì‚†Ä‚†Ä‚†Ä‚††‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              

# ===[ FastAPI Introduction ]===================================================
 FastAPI is a modern python web framework designed to build fast APIs  

===[ Uvicorn: Application Server (CGI) ]===
- 'uvicorn' is fast, lightweight 'application server' used to run python web
  application, especially those build with framework like 'FastAPI' and
  'Starlette'.
  -> It is based on 'ASGI (Async Server Gateway Interface)' which allows it to
     handle many requests at the same time without waiting for one to finish
     before (Async tasks) before starting another. 
  -> Uvicorn handles both 'Async' and 'Sync' tasks. 
  
  # QUESTION:[ How does uvicorn handle both tasks `Async` and `Sync`? ]=========
  # - In uvicorn, each woker runs the app inside an 'event loop (using asyncio)'
  # - Here is how it handles both types of tasks:
  #   > Async Tasks: These run directly on the event loop, uvicorn schedules and
  #     switches between them efficiently without blocking.
  #   > Sync tasks: When a synchronous function is called, uvicorn runs it in a
  #     'separate thread pool', so it doesn't block the event loop.
  # QUESTION:[ What is the diffence betwen 'Daphne' and 'Uvicorn'? ]============
  # - As I already know that daphne asigns the task the worker, if the task
  #   is an `Async` task, it the task is an `async` task it is handled using
  #   and event loop inside a worker, otherwise it is a `sync` task that
  #   assigned to a worker.
  # INFO:> 'Execution Pool': means the type of workers that handle tasks
  #   - It can be a single thread (event loop pool) or
  #   - multiple threads (thread pool) or 
  #   - Multiple process (process pool)
  # > 'Daphne' VS 'Uvicorn'
  #   - Uvicorn: `async` event loop + thread pool for `sync` tasks (event loop) 
  #   - Daphne: `async` event loop + sync runs on single worker (multi-process) 
  # ============================================================================

  > [ General Structure ]

    from fastapi import FastAPI

    # Creating a FastAPI instance
    instance = FastAPI()

    # Create an HTTP Method (GET, POST, PUT, DELETE)
    @instance.get('route /[path_parameters]') [post, put, delete]
    [async] def func():
      # code

===[ URL/Request Parameters ]===================================================
- Since the 'GET' request does not have a body we use the 'URL Paramters' to  
  send the data.

  |------------------------[ URL/Request Parameters ]---------------------|
  |                                                                       |
[ Path Parameters ]                                         [ Query Paramaters ]

===[ Path Parameters ]===
- Think of 'path parameters' as 'placeholders' in your 'URL' that let your API 
  accept 'dynamic values'.

> [ Analogy ]
- Imagine a 'mail delivery system', you do not deliver mail to 'house 1',
  'house 2', 'house 3' one by one manullay, instead you have an address
  placeholder:

    /house/{house_number}

  - When a delivery comes for house 42, you just replace `{house_number}` with
    `42`, FastAPI does the same thing with URLs


  @app.get("/users/{user_id}")
  def read_user(user_id: int):
    return {"user_id: user_id"}


  # CONCLUSION:=================================================================
  # >> Path parameters make your routes flexible.                              |
  # ============================================================================

===[ Query Parameters ]===
 'Query Parameters' are extra bits of data you add to the URL 'after a'
  'question mark `?`' 
  - The are usually 'optional filters or options'.

  > Example:

    [   /items/?skip=10&limit=5   ]

    . `skip=10` and `limit=5` are query parameters
    # NOTE:> Query paramters ARE NOT part of the path like `/items/{item_id}`

===[ Automatic API Documentation (Swagger UI) ]=================================
 'FastAPI' automatically creates 'interactive doumentation pages' for your API
  , 'Without you writing any extra code'.
  - These pages help you:
    . See all your API endpoints
    . Understand what each one does 
    . Test them directly in your browser 
  -> It is like FastAPI gives you a 'control panel' for your API automatically.


> [ How it Works ]
  - When you create routes (endpoints) using FastAPI, It already knows: 
    . The HTTP method (GET, POST, PUT, DELETE)
    . The path (`items/{id}`) 
    . The Excepted input and output types 

  -> Using this informations, 'FastAPI' automatically builds 'documentation'
    'pages' following the 'OpenAPI standard (a global standard for describing'
    'APIs)'.


> [ Accessing the Docs ]
  - Once you run your app (`uvicorn main:app --reload`) open your browser and
    visit:
    > 'Swagger UI': `https://127.0.0.1:8000/docs` 
    > 'ReDoc' (alternative view):  `https://127.0.0.1:8000/redoc`
  -> both show your API automatically, no setup required 

===[ Pydantic Schemas & Validation ]===========================================
 'Pydantic' is a library that 'validates and parses data' using 'python type' 
  'hints'.
  - FastAPI uses it internally to 'make sure the data coming into (or out of)'
    'your API is' 'the right type complete' and 'clean'.

===[ Schema ]===
  - A 'Schema' is basically a 'data model' that defines what a request or 
    response should look like, you create it by defining a 'Pydantic class' that
    inherits from `BaseModel`.

    - Example:
      from pydantic import BaseModel

      class User(BaseModel):
        # attributes
        name: str
        age: int
        email: str

    @app.get('/')
    def request(user: User)
        return {"message": f"User {user.name] created succesfully!}"}

    - If a request like this comes in:
      {
          "name": "Oussame",
          "age": 25,
          "email": "oussame@example.com"
      }
    - It works fine, but if `age` is missing or "age: five", FastAPI
      automatically returns a '422 validation error - you do not even'
      'have to code it yourself'.

===[ Filed: Validation Rules (extra features) ]===
  - Pydantic lets you add 'extra validation' or 'constraints' using special
    'fields' or 'decorators'.

  [ Example: ]-----------------------------------------------------------------|
  | from pydantic export BaseModel, Fieldm EmailStr                            |
  |                                                                            |
  | class User(BaseModel):                                                     |
  |   name: str = Field(..., min_length=3, max_length=50)                      |
  |   age: int = Field(..., ge=18, le=100, description="user's email address") |
  |   email: EmailStr                                                          |
  |                                                                            |
  |   > `EmailStr`: validates proper email format                              |
  |   > `min_length`, `max_length`, `ge`, `le` check limits                    |
  |   > `...`: means required filed                                            |
  |   > `description`: adds documentation info for OpenAPI (Swagger UI)        | 
  -----------------------------------------------------------------------------| 

  > [ Field Attributes ]
    . `...`: (ellipsis) -> means 'required field' 
    . `min_lenth`/`max_length` -> validate string lenth 
    . `ge`/`le` (less or equal) -> numeric validation  
    . `alias`: use another name in input/output
    . `title`: Title used in docs / OpenAPI schema 
    . `description`: Text description for docs
    . `example`: example value for docs
    . `deprecated`: mark field as deprecated in docs

===[ Response Models ]===
  - You can also use schemas to 'control what data is returned' to the client.

    @app.get("user/{user_id}", response_model=User)
    def get_user(user_id: int):
        return {"name": "oussama", "age": 25, "email": "oussama@exmaple.com"}

    > FastAPI will:
      - Validate the response data before sending it
      - Exclude unexpected fields automatically
  _____________________________________________________________________
  | Concept             | Description                                 |
  |---------------------|---------------------------------------------|
  |- Schema             |- A class defining structure & types of data |
  |- Validation         |- Automatic checks by Pydantic               |
  |- Request Model      |- Validates incoming data                    |
  |- Response Model     |- Validates and shapes outgoing data         |
  |_____________________|_____________________________________________|


# INFO:=========================================================================
# - Try to define the Schema of each request for more readability and this     |
#   is the profitional way to do it.                                           |
# >> Look at the `main.py` explain in `test/` directory                        |
# ==============================================================================

===[ Optional class ]===
- The 'Optional' class from the 'typing' module is used to 'indicate that a'
  'variable parameter, or return value can be either a specific type or `None`'
  - It is a shorthand for saying:

      [   Optional[X] == Union[X, None]   ] 

  - So `Optional[int]` means "this value can be an `int` or `None`".

> [ Why do we use it ]
  - When writing functions, you often have parameters or return values that
    might 'not always contain data', sometimes they can be missing, undefined
    , or intentionally empty ('None').
  - `Optional` helps you 'make that explicit' in your code, useful for both
    readability and type checking tools (like `mypy` or your IDE)

  # INFO:============================================================
  # - If you are using `Python 3.10+` you can use a shorter syntax: |
  #   def greet(name: str | None):                                  |
  #     pass                                                        |
  # - This means exactly the same as `Optional[str]`.               |
  # =================================================================

===[ HTTP Exceptions ]==========================================================
- In FastAPI, an 'HTTP Exception' represents an intentional HTTP error response
  you 'raise from insdie your code', typically when something goes wrong in your
  API logic.

  > It's a special kind of exception that tells FastAPI:
    
  [ Stop normal execution and return an HTTP response with this status code, ]
  [ message and details.                                                     ]

  > [ The class: `fastapi.HTTPException` ] 

    # Import
    from fastapi import HTTPException

    # Exmaple 
    return HTTPException(status_code=404, detail="Item not found") 

  # INFO:----------------------------------------------------------------------
  # - HTTPException tells the program to stop the execution and raise and HTTP|
  #   HTTP Exception.                                                         |
  # - Common Use: 404 ‚Äúnot found‚Äù, 401 ‚Äúunauthorized‚Äù, 400 ‚Äúbad request‚Äù      |
  # ---------------------------------------------------------------------------

===[ FastAPI Structure ]=======================================================
project/
‚îÇ
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py             # FastAPI app instance
‚îÇ   ‚îú‚îÄ‚îÄ asgi.py             # optional if using ASGI server
‚îÇ   ‚îú‚îÄ‚îÄ settings.py         # environment-dependent settings
‚îÇ   ‚îú‚îÄ‚îÄ config.py           # constants, static paths, magic numbers
‚îÇ   ‚îú‚îÄ‚îÄ ml_models/          # machine learning trained models 
‚îÇ       ‚îú‚îÄ‚îÄ model.joblib 
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zone_processing_time.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ other_routes.py
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logger.py
‚îÇ   ‚îî‚îÄ‚îÄ models/             # Pydantic models or ORM models
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ .dockerignore
‚îî‚îÄ‚îÄ README.md

===[ `settings.py` ]===
> Purpose:
  - Defines 'environment-specific, changeable configuation'
  - Typically loaded at 'runtime' 
  - May read from 'environment variables', '.env' or external config sources 

-> runtime configuration, environment-specific, loaded via 'Pydantic' or
   'os.environ' 
  
  # app/settings.py
  from pydantic import BaseSettings

  class Settings(BaseSettings):
      APP_NAME: str = "Simulation API"
      DEBUG: bool = true
      HOST: str = "0.0.0.0"
      PORT: int = 3000
      LOGS_DIR: str = "/app/logs" 

  settings = Settings()   # or get_settings() function

  > Notes:
    - Can change values without changing code (via environement variables) 
    - often used in dependency injection in FastAPI:

# import settings
  from app.settings import settings

  print(settings.APP_NAME)
  # - Creates a new FastAPI app object
  # - Sets a 'custom title' for the automatic docs 
  # - Turns 'debug mode' on or off depending on the configuration 
  FastAPI(title=settings.APP_NAME, debug=settings.DEBUG)
  # > [ purpose: title ]
  #   . Sets the title of your API
  #   . Where it shows up: The title appears in 'automatic API documentation' 
  #     that FastAPI generates (Swagger UI and ReDoc)
  #   . `settings.APP_NAME` means the title is being read from some `settings`
  #     object or module, usually from 'environment variables' or 'config file'


===[ `config.py` ]===
> Purpose:
  - defines 'constants and static values'
  - usually 'hardcoded', not 'not depend on environment' 
  - Independent and reusable across the project 
  - Safe to import anywhere without circular import problems 

===[ `__init__.py` ]===
  ___________________________
  | Purpose           | Use |
  |-------------------|-----|
  | Mark package      | ‚úî   |
  | Clean imports     | ‚úî   |
  | Expose public API | ‚úî   |
  | Run heavy logic   | ‚ùå  |
  |___________________|_____|

===[ `config.py` VS `settings.py` ]===
  - The core idea ('this is the rule')
    "Can this value realistically change between environments or deployments"
    "without touching code?"
    - IF 'YES'  -> `settings` 
    - IF 'NO'   -> `config`
    . That's it, Everything else is details

  > [ `settings` = HOw the app is deployed ]
    - Things that depend on: 
      . environment (dev / stagin / prod)
      . secrets
      . infrastructure 
      . ops / DevOps decisions
    - These are usually:
      . loaded from env vars
      . different per machine
      . not part off the app's "identity"
    - Examples:
      . DATABASE_URL
      . REDIS_URL
      . DEBUG
      . LOG_LEVEL 
      . SECRET_KEY
      . JWT_SECRET
    -> You Expect these to change when:
      . you deploy somewhere else
      . someone else runs the app 
      . CI/CD runs it

  > [ `config` = How the app behaves ] 
    - Thins that define:
      . rules
      . policies
      . limits 
      . structure
    - These are:
      . mostly static
      . part of the codebase logic
      . changed intentionally by developers 
    - Examples:
      . CORS_ORIGINS
      . API_PREFIX = "/api/v1"
      . MAX_PAGE_SIZE = 100
      . PASSWORD_MIN_LENGTH = 12
      . DEFAULT_TIMEZONE = 'UTC'
    -> You do not 'expect' these to change randomly per server

# QUESTION:[ Why Cors belong to config? ]--------------------------------------
# - Why CORS belongs in `config`:
# - Ask the question:
#   "Should CORS change just because I deploy to another machines?"
#   -> `NO`, It's a 'security plicy' not infra.
# -- hort answer (truth, no tricks) --
# üëâ Config can change between development and production
# üëâ But it changes by decision, not by necessity
#    -> That distinction is everything.
# -- The refined rule (this is the real one) --
#    Ask two questions, in this order:
#   1Ô∏è‚É£Must this change for the app to run?
# - Yes ‚Üí settings
# - No ‚Üí go to question 2
# -- Is this a policy / rule / behavior decision?
#    - Yes ‚Üí config
#    - No ‚Üí settings
# -----------------------------------------------------------------------------

  > [ Why this works so well? ]
    - Because
      -> `settings` are 'external facts'
      -> `config` is 'internal decisions' 

  __________________________________________________
  | Variable       | Why it changes     | Where    |
  |----------------|--------------------|----------|
  | DEBUG          | Safety / verbosity | config   |
  | CORS_ORIGINS   | Security policy    | config   |
  | API_RATE_LIMIT | Abuse prevention   | config   |
  | DATABASE_URL   | Infra              | settings |
  | REDIS_HOST     | Infra              | settings |
  | SECRET_KEY     | Security secret    | settings |
  |________________|____________________|__________|

  _____________________________________________________________________________
  | Feature               |           `settings.py`       |    `config.py`    |
  |-----------------------|-------------------------------|-------------------|
  | Environment-dependent | ‚úÖ (via env vars or .env)     | ‚ùåusually static  |
  |-----------------------|-------------------------------|-------------------|
  | Changeable at runtime | ‚úÖ                            | ‚ùå                |
  |-----------------------|-------------------------------|-------------------|
  | Safe to import        | ‚ö†Ô∏è can cause circular imports | ‚úÖ                |
  | anywhere              |                               |                   | 
  |-----------------------|-------------------------------|-------------------|
  | Purpose               | App settings, configurable    | Constants, static |
  |                       | behavior                      | configuration     |
  |_______________________|_______________________________|___________________|
